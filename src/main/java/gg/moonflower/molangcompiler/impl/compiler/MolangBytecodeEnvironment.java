package gg.moonflower.molangcompiler.impl.compiler;

import gg.moonflower.molangcompiler.api.exception.MolangSyntaxException;
import org.jetbrains.annotations.ApiStatus;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.tree.MethodNode;

import java.util.HashMap;
import java.util.LinkedHashSet;
import java.util.Map;
import java.util.Set;

/**
 * Manages compilation state and local variable allocation during bytecode generation.
 * <p>
 * This record tracks the mapping between MoLang variables (e.g., {@code temp.x}, {@code query.health})
 * and JVM local variable indices in the generated bytecode. It also tracks which variables have been
 * modified during execution to ensure they are written back to their respective objects.
 * <p>
 * Key responsibilities:
 * <ul>
 *   <li>Allocating local variable slots for MoLang variables</li>
 *   <li>Caching object references (query, temp, context, etc.) in local variables</li>
 *   <li>Tracking modified variables that need to be persisted</li>
 *   <li>Managing optimization flags for constant folding</li>
 * </ul>
 * <p>
 * The local variable table layout in generated methods:
 * <ul>
 *   <li>Index 0: {@code this} reference</li>
 *   <li>Index 1: {@code MolangEnvironment runtime} parameter</li>
 *   <li>Index 2+: Allocated MoLang variables and objects</li>
 * </ul>
 *
 * @param variables         Map from variable keys (e.g., "temp.x") to local variable indices
 * @param modifiedVariables Set of variable keys that have been modified and need to be written back
 * @param optimize          Whether optimization (constant folding) is enabled
 * @author Ocelot
 * @since 1.0.0
 */
@ApiStatus.Internal
public record MolangBytecodeEnvironment(Map<String, Integer> variables,
                                        Set<String> modifiedVariables,
                                        boolean optimize) {

    /**
     * Creates a new environment by copying an existing one.
     * <p>
     * The modified variables set is not copied (starts empty).
     *
     * @param environment The environment to copy from
     */
    public MolangBytecodeEnvironment(MolangBytecodeEnvironment environment) {
        this(new HashMap<>(environment.variables), new LinkedHashSet<>(), environment.optimize);
    }

    /**
     * Creates a new environment from compilation flags.
     *
     * @param flags Compilation flags (e.g., {@link BytecodeCompiler#FLAG_OPTIMIZE})
     */
    public MolangBytecodeEnvironment(int flags) {
        this(new HashMap<>(), new LinkedHashSet<>(), (flags & BytecodeCompiler.FLAG_OPTIMIZE) > 0);
    }

    /**
     * Fully resets the environment, clearing all variable allocations and modifications.
     * <p>
     * This is called before compiling each new expression to ensure clean state.
     */
    public void reset() {
        this.variables.clear();
        this.modifiedVariables.clear();
    }

    /**
     * Loads a MoLang variable into a local variable slot, generating bytecode if not already loaded.
     * <p>
     * This method ensures that each variable is loaded only once per expression evaluation.
     * Subsequent accesses to the same variable will reuse the cached local variable index.
     * <p>
     * The generated bytecode performs:
     * <ol>
     *   <li>Get the object (query, temp, etc.) containing the variable</li>
     *   <li>Call {@code object.get(name)} to retrieve the MolangExpression</li>
     *   <li>Call {@code runtime.resolve(expression)} to evaluate it</li>
     *   <li>Store the result in a local variable</li>
     * </ol>
     *
     * @param method The method node to generate bytecode in
     * @param object The object name (e.g., "query", "temp", "variable")
     * @param name   The variable name within the object
     * @return The local variable index where the value is stored
     */
    public int loadVariable(MethodNode method, String object, String name) {
        String key = object + "." + name;
        Integer index = this.variables.get(key);
        if (index != null) {
            return index;
        }

        // Resolve value
        method.visitVarInsn(Opcodes.ALOAD, BytecodeCompiler.RUNTIME_INDEX);

        // Get variable
        int objectIndex = this.getObjectIndex(method, object);
        method.visitVarInsn(Opcodes.ALOAD, objectIndex);
        method.visitLdcInsn(name);
        method.visitMethodInsn(
                Opcodes.INVOKEINTERFACE,
                "gg/moonflower/molangcompiler/api/object/MolangObject",
                "get",
                "(Ljava/lang/String;)Lgg/moonflower/molangcompiler/api/MolangExpression;",
                true
        );

        method.visitMethodInsn(
                Opcodes.INVOKEINTERFACE,
                "gg/moonflower/molangcompiler/api/MolangEnvironment",
                "resolve",
                "(Lgg/moonflower/molangcompiler/api/MolangExpression;)Lgg/moonflower/molangcompiler/api/MolangValue;",
                true
        );

        // Store result
        index = this.allocateVariable(key);
        method.visitVarInsn(Opcodes.ASTORE, index);
        return index;
    }

    /**
     * Allocates a space for a new variable, but doesn't initialize it.
     *
     * @param name The full name of the variable, including any objects it may be in
     * @return The index the variable can be loaded into
     */
    public int allocateVariable(String name) {
        Integer index = this.variables.get(name);
        if (index != null) {
            return index;
        }

        // Calculate variable offset
        index = this.variables.size() + BytecodeCompiler.VARIABLE_START;
        this.variables.put(name, index);
        return index;
    }

    /**
     * Retrieves the local variable index for a MoLang object, loading it if necessary.
     * <p>
     * Objects are the top-level containers for variables in MoLang (query, temp, context, etc.).
     * This method generates bytecode to call the appropriate getter method on the runtime environment.
     * <p>
     * Recognized object aliases:
     * <ul>
     *   <li>{@code context}, {@code c} → {@code runtime.getContext()}</li>
     *   <li>{@code query}, {@code q} → {@code runtime.getQuery()}</li>
     *   <li>{@code global} → {@code runtime.getGlobal()}</li>
     *   <li>{@code variable}, {@code v} → {@code runtime.getVariable()}</li>
     *   <li>Other names → {@code runtime.get(name)}</li>
     * </ul>
     *
     * @param method The method node to generate bytecode in
     * @param object The object name (e.g., "query", "temp", "variable")
     * @return The local variable index where the object reference is stored
     */
    public int getObjectIndex(MethodNode method, String object) {
        Integer index = this.variables.get(object);
        if (index != null) {
            return index;
        }

        index = this.allocateVariable(object);

        method.visitVarInsn(Opcodes.ALOAD, BytecodeCompiler.RUNTIME_INDEX);
        if ("context".equalsIgnoreCase(object) || "c".equalsIgnoreCase(object)) {
            method.visitMethodInsn(
                    Opcodes.INVOKEINTERFACE,
                    "gg/moonflower/molangcompiler/api/MolangEnvironment",
                    "getContext",
                    "()Lgg/moonflower/molangcompiler/api/object/MolangObject;",
                    true);
        } else if ("query".equalsIgnoreCase(object) || "q".equalsIgnoreCase(object)) {
            method.visitMethodInsn(
                    Opcodes.INVOKEINTERFACE,
                    "gg/moonflower/molangcompiler/api/MolangEnvironment",
                    "getQuery",
                    "()Lgg/moonflower/molangcompiler/api/object/MolangObject;",
                    true);
        } else if ("global".equalsIgnoreCase(object)) {
            method.visitMethodInsn(
                    Opcodes.INVOKEINTERFACE,
                    "gg/moonflower/molangcompiler/api/MolangEnvironment",
                    "getGlobal",
                    "()Lgg/moonflower/molangcompiler/api/object/MolangObject;",
                    true);
        } else if ("variable".equalsIgnoreCase(object) || "v".equalsIgnoreCase(object)) {
            method.visitMethodInsn(
                    Opcodes.INVOKEINTERFACE,
                    "gg/moonflower/molangcompiler/api/MolangEnvironment",
                    "getVariable",
                    "()Lgg/moonflower/molangcompiler/api/object/MolangObject;",
                    true);
        } else {
            method.visitLdcInsn(object);
            method.visitMethodInsn(
                    Opcodes.INVOKEINTERFACE,
                    "gg/moonflower/molangcompiler/api/MolangEnvironment",
                    "get",
                    "(Ljava/lang/String;)Lgg/moonflower/molangcompiler/api/object/MolangObject;",
                    true);
        }
        method.visitVarInsn(Opcodes.ASTORE, index);

        return index;
    }

    /**
     * Loads whether the specified object has the specified variable onto the stack.
     *
     * @param method The method to insert code into
     * @param object The name of the object to query
     * @param name   The name of the variable to test for
     */
    public void loadObjectHas(MethodNode method, String object, String name) {
        if ("temp".equals(object)) {
            method.visitLdcInsn(this.variables.containsKey("temp." + name));
            return;
        }

        String key = object + "." + name + "$has";
        Integer objectHasIndex = this.variables.get(key);
        if (objectHasIndex != null) {
            method.visitVarInsn(Opcodes.ILOAD, objectHasIndex);
            return;
        }

        objectHasIndex = this.allocateVariable(key);

        int objectIndex = this.getObjectIndex(method, object);
        method.visitVarInsn(Opcodes.ALOAD, objectIndex);
        method.visitLdcInsn(name);
        method.visitMethodInsn(
                Opcodes.INVOKEINTERFACE,
                "gg/moonflower/molangcompiler/api/object/MolangObject",
                "has",
                "(Ljava/lang/String;)Z",
                true
        );
        method.visitInsn(Opcodes.DUP);
        method.visitVarInsn(Opcodes.ISTORE, objectHasIndex);
    }

    /**
     * Marks the specified object as requiring an update before returning.
     *
     * @param object The name of the object the variable is in
     * @param name   The name of the variable to mark dirty
     */
    public void markDirty(String object, String name) {
        // Don't try to save temporary variables
        if ("temp".equals(object)) {
            return;
        }
        this.modifiedVariables.add(object + "." + name);
    }

    /**
     * Writes all modified variables back into their objects.
     *
     * @param method The method to write values back into
     * @throws MolangSyntaxException If any error occurs with the format of the variables
     */
    public void writeModifiedVariables(MethodNode method) throws MolangSyntaxException {
        for (String name : this.modifiedVariables) {
            Integer index = this.variables.get(name);
            if (index == null) {
                throw new MolangSyntaxException("Unknown variable index: " + name);
            }

            String[] parts = name.split("\\.", 2);
            if (parts.length != 2) {
                throw new MolangSyntaxException("Expected 2 variable parts for " + name + ", got " + parts.length);
            }

            int objectIndex = this.getObjectIndex(method, parts[0]);

            method.visitVarInsn(Opcodes.ALOAD, objectIndex);
            method.visitLdcInsn(parts[1]);
            method.visitVarInsn(Opcodes.ALOAD, index);
            method.visitMethodInsn(
                    Opcodes.INVOKESTATIC,
                    "gg/moonflower/molangcompiler/impl/MolangUtil",
                    "setValue",
                    "(Lgg/moonflower/molangcompiler/api/object/MolangObject;Ljava/lang/String;Lgg/moonflower/molangcompiler/api/MolangValue;)V",
                    false
            );
        }
        this.modifiedVariables.clear();
    }
}
