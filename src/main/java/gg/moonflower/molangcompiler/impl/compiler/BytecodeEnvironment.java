package gg.moonflower.molangcompiler.impl.compiler;

import gg.moonflower.molangcompiler.api.exception.MolangSyntaxException;
import lombok.Getter;
import org.jetbrains.annotations.ApiStatus;
import org.objectweb.asm.tree.MethodNode;

/**
 * Manages compilation state and local variable allocation during bytecode generation.
 * <p>
 * This record tracks the mapping between MoLang variables (e.g., {@code temp.x}, {@code query.health})
 * and JVM local variable indices in the generated bytecode. It also tracks which variables have been
 * modified during execution to ensure they are written back to their respective objects.
 * <p>
 * Key responsibilities:
 * <ul>
 *   <li>Allocating local variable slots for MoLang variables</li>
 *   <li>Caching object references (query, temp, context, etc.) in local variables</li>
 *   <li>Tracking modified variables that need to be persisted</li>
 *   <li>Managing optimization flags for constant folding</li>
 * </ul>
 * <p>
 * The local variable table layout in generated methods:
 * <ul>
 *   <li>Index 0: {@code this} reference</li>
 *   <li>Index 1: {@code MolangEnvironment runtime} parameter</li>
 *   <li>Index 2+: Allocated MoLang variables and objects</li>
 * </ul>
 *
 * @author irrelevantdev
 * @since 4.0.0
 */
@ApiStatus.Internal
public abstract class BytecodeEnvironment {

    @Getter
    protected final int thisIndex;
    @Getter
    protected final int runtimeIndex;
    @Getter
    protected final int variableStartIndex;

    public BytecodeEnvironment(int thisIndex, int runtimeIndex, int variableStartIndex) {
        this.thisIndex = thisIndex;
        this.runtimeIndex = runtimeIndex;
        this.variableStartIndex = variableStartIndex;
    }

    public abstract void reset();

    /**
     * Loads a MoLang variable into a local variable slot, generating bytecode if not already loaded.
     * <p>
     * This method ensures that each variable is loaded only once per expression evaluation.
     * Subsequent accesses to the same variable will reuse the cached local variable index.
     * <p>
     * The generated bytecode performs:
     * <ol>
     *   <li>Get the object (query, temp, etc.) containing the variable</li>
     *   <li>Call {@code object.get(name)} to retrieve the MolangExpression</li>
     *   <li>Call {@code runtime.resolve(expression)} to evaluate it</li>
     *   <li>Store the result in a local variable</li>
     * </ol>
     *
     * @param method The method node to generate bytecode in
     * @param object The object name (e.g., "query", "temp", "variable")
     * @param name   The variable name within the object
     * @return The local variable index where the value is stored
     */
    public abstract int loadVariable(MethodNode method, String object, String name);

    /**
     * Allocates a space for a new variable, but doesn't initialize it.
     *
     * @param name The full name of the variable, including any objects it may be in
     * @return The index the variable can be loaded into
     */
    public abstract int allocateVariable(String name);

    /**
     * Retrieves the local variable index for a MoLang object, loading it if necessary.
     * <p>
     * Objects are the top-level containers for variables in MoLang (query, temp, context, etc.).
     * This method generates bytecode to call the appropriate getter method on the runtime environment.
     * <p>
     * Recognized object aliases:
     * <ul>
     *   <li>{@code context}, {@code c} → {@code runtime.getContext()}</li>
     *   <li>{@code query}, {@code q} → {@code runtime.getQuery()}</li>
     *   <li>{@code global} → {@code runtime.getGlobal()}</li>
     *   <li>{@code variable}, {@code v} → {@code runtime.getVariable()}</li>
     *   <li>Other names → {@code runtime.get(name)}</li>
     * </ul>
     *
     * @param method The method node to generate bytecode in
     * @param object The object name (e.g., "query", "temp", "variable")
     * @return The local variable index where the object reference is stored
     */
    public abstract int getObjectIndex(MethodNode method, String object);

    /**
     * Loads whether the specified object has the specified variable onto the stack.
     *
     * @param method The method to insert code into
     * @param object The name of the object to query
     * @param name   The name of the variable to test for
     */
    public abstract void loadObjectHas(MethodNode method, String object, String name);

    /**
     * Marks the specified object as requiring an update before returning.
     *
     * @param object The name of the object the variable is in
     * @param name   The name of the variable to mark dirty
     */
    public abstract void markDirty(String object, String name);

    /**
     * Writes all modified variables back into their objects.
     *
     * @param method The method to write values back into
     * @throws MolangSyntaxException If any error occurs with the format of the variables
     */
    public abstract void writeModifiedVariables(MethodNode method) throws MolangSyntaxException;

    public abstract Integer getVariableIndex(String variable);

    public abstract BytecodeEnvironment copy();
}
