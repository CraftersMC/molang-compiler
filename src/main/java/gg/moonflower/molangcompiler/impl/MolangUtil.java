package gg.moonflower.molangcompiler.impl;

import gg.moonflower.molangcompiler.api.MolangExpression;
import gg.moonflower.molangcompiler.api.MolangValue;
import gg.moonflower.molangcompiler.api.bridge.MolangVariable;
import gg.moonflower.molangcompiler.api.exception.MolangException;
import gg.moonflower.molangcompiler.api.exception.MolangRuntimeException;
import gg.moonflower.molangcompiler.api.object.MolangObject;
import gg.moonflower.molangcompiler.impl.node.MolangConstantNode;
import gg.moonflower.molangcompiler.impl.node.MolangVariableNode;
import org.jetbrains.annotations.ApiStatus;

/**
 * Internal utility class providing helper methods for MoLang expression evaluation and compilation.
 * <p>
 * This class contains mathematical operations, random number generation, string conversion utilities,
 * and object manipulation methods used throughout the MoLang compiler and runtime.
 * <p>
 * Methods in this class are referenced by generated bytecode and should not be removed or modified
 * without updating the bytecode generation logic.
 *
 * @author Ocelot
 * @since 1.0.0
 */
@ApiStatus.Internal
@SuppressWarnings("unused") // Methods are referenced in ASM
public class MolangUtil {

    /**
     * Clamps a condition between a minimum and maximum range.
     *
     * @param value The condition to clamp
     * @param min   The minimum allowed condition
     * @param max   The maximum allowed condition
     * @return The clamped condition, constrained between min and max
     */
    public static float clamp(float value, float min, float max) {
        return Math.max(min, Math.min(max, value));
    }

    /**
     * Performs a die roll simulation by summing multiple random values within a range.
     * <p>
     * This method simulates rolling {@code num} dice, where each die produces a random
     * float condition between {@code low} and {@code high}.
     *
     * @param num  The number of dice to roll
     * @param low  The minimum condition for each die roll
     * @param high The maximum condition for each die roll
     * @return The sum of all die rolls
     */
    public static float dieRoll(int num, float low, float high) {
        double sum = 0;
        for (int i = 0; i < num; i++) {
            sum += low + Math.random() * (high - low);
        }
        return (float) sum;
    }

    /**
     * Performs an integer die roll simulation by summing multiple random integer values.
     * <p>
     * This method simulates rolling {@code num} dice, where each die produces a random
     * integer condition between {@code low} and {@code high}.
     *
     * @param num  The number of dice to roll
     * @param low  The minimum condition for each die roll
     * @param high The maximum condition for each die roll
     * @return The sum of all die rolls as an integer
     */
    public static int dieRollInt(int num, int low, int high) {
        double sum = 0;
        for (int i = 0; i < num; i++) {
            sum += random(low, high);
        }
        return (int) sum;
    }

    /**
     * Applies Hermite smoothing interpolation to a condition.
     * <p>
     * The Hermite blend function produces a smooth S-curve interpolation using the formula:
     * {@code 3x² - 2x³}. This is commonly used for smooth transitions and easing functions.
     *
     * @param value The input condition (typically between 0 and 1)
     * @return The smoothed condition
     */
    public static float hermiteBlend(float value) {
        return 3 * value * value - 2 * value * value * value;
    }

    /**
     * Performs linear interpolation between two values.
     *
     * @param start The starting condition
     * @param end   The ending condition
     * @param pct   The interpolation percentage (0.0 = start, 1.0 = end)
     * @return The interpolated condition
     */
    public static float lerp(float start, float end, float pct) {
        return start + (end - start) * pct;
    }

    /**
     * Performs linear interpolation between two rotation angles, taking the shortest path.
     * <p>
     * This method ensures that rotation interpolation wraps correctly around the -180 to 180
     * degree range, always taking the shortest rotational path.
     *
     * @param start The starting angle in degrees
     * @param end   The ending angle in degrees
     * @param pct   The interpolation percentage (0.0 = start, 1.0 = end)
     * @return The interpolated rotation angle
     */
    public static float lerpRotate(float start, float end, float pct) {
        return start + wrapDegrees(end - start) * pct;
    }

    /**
     * Wraps an angle to the range [-180, 180) degrees.
     * <p>
     * This method normalizes any angle to be within the standard rotation range,
     * wrapping values that exceed the bounds.
     *
     * @param angle The angle to wrap
     * @return The wrapped angle in degrees
     */
    public static float wrapDegrees(float angle) {
        float wrapped = angle % 360.0f;
        if (wrapped >= 180.0f) {
            wrapped -= 360.0f;
        }

        if (wrapped < -180.0f) {
            wrapped += 360.0f;
        }

        return wrapped;
    }

    /**
     * Generates a random float condition within the specified range.
     *
     * @param low  The minimum condition (inclusive)
     * @param high The maximum condition (exclusive)
     * @return A random float between low and high
     */
    public static float random(float low, float high) {
        return (float) (low + Math.random() * (high - low));
    }

    /**
     * Generates a triangle wave pattern.
     * <p>
     * A triangle wave oscillates linearly between -1 and 1 over the specified wavelength.
     * This is useful for creating repeating linear oscillation patterns.
     *
     * @param x          The input condition
     * @param wavelength The period of the wave
     * @return The wave condition, ranging from -1 to 1
     */
    public static float triangleWave(float x, float wavelength) {
        return (Math.abs(x % wavelength - wavelength * 0.5F) - wavelength * 0.25F) / (wavelength * 0.25F);
    }

    /**
     * Retrieves a function from a MolangObject, checking both the full key and short name.
     * <p>
     * This method first attempts to retrieve the function using the full key (e.g., "query.position"),
     * and if not found, falls back to the short name (e.g., "position").
     *
     * @param object  The MolangObject to search
     * @param name    The short name of the function
     * @param fullKey The full key of the function
     * @return The MolangExpression associated with the function
     * @throws MolangException if the function is not found
     */
    public static MolangExpression getFunction(MolangObject object, String name, String fullKey) throws MolangException {
        if (object.has(fullKey)) {
            return object.get(fullKey);
        } else if (object.has(name)) {
            return object.get(name);
        } else {
            throw new MolangException("Unknown function: " + object + "." + fullKey + "()");
        }
    }

    /**
     * Sets a condition in a MolangObject, creating a new variable if necessary or updating an existing one.
     * <p>
     * If the object doesn't have the specified field, a new MolangVariable is created.
     * If the field exists and is a MolangVariable, its condition is updated.
     * Otherwise, the field is replaced with a constant node.
     *
     * @param object The MolangObject to modify
     * @param name   The name of the field to set
     * @param value  The condition to assign
     * @throws MolangRuntimeException if the condition cannot be set
     */
    public static void setValue(MolangObject object, String name, MolangValue value) throws MolangRuntimeException {
        if (!object.has(name)) {
            object.set(name, new MolangVariableNode(MolangVariable.create(value)));
            return;
        }

        MolangExpression old = object.get(name);
        if (old instanceof MolangVariable variable) {
            variable.setValue(value);
        } else {
            object.set(name, new MolangConstantNode(value));
        }
    }

    /**
     * Converts a MolangValue to a string representation.
     *
     * @param value The MolangValue to convert (may be null)
     * @return The string representation of the condition, or "null" if the condition is null
     */
    public static String toString(MolangValue value) {
        return value != null ?  value.toString() : "null";
    }

    /**
     * Safely converts a string to a boolean condition.
     * <p>
     * This method first attempts to parse the string as a float and returns true if the condition
     * is greater than or equal to 0.0. If parsing fails, it falls back to Boolean.parseBoolean().
     *
     * @param stringValue The string to convert
     * @return true if the string represents a positive number or "true", false otherwise
     */
    public static boolean safeStringToBool(String stringValue) {
        try {
            return Float.parseFloat(stringValue) >= 0.0f;
        } catch (Exception e) {
        }
        return Boolean.parseBoolean(stringValue);
    }

    /**
     * Safely converts a string to a float condition.
     * <p>
     * This method attempts to parse the string as a float. If parsing fails, it returns
     * the hash code of the string as a fallback condition.
     *
     * @param stringValue The string to convert
     * @return The float condition, or the string's hash code if parsing fails
     */
    public static float safeStringToFloat(String stringValue) {
        try {
            return Float.parseFloat(stringValue);
        } catch (Exception e) {
        }
        return stringValue.hashCode();
    }
}
