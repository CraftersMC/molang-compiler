package gg.moonflower.molangcompiler.impl.ast;

import gg.moonflower.molangcompiler.api.MolangValue;
import gg.moonflower.molangcompiler.api.exception.MolangException;
import gg.moonflower.molangcompiler.impl.compiler.MolangBytecodeEnvironment;
import org.jetbrains.annotations.ApiStatus;
import org.jetbrains.annotations.Nullable;
import org.objectweb.asm.Label;
import org.objectweb.asm.tree.MethodNode;

/**
 * Base interface for all nodes in the Abstract Syntax Tree (AST).
 * <p>
 * Nodes represent individual language constructs in the MoLang expression tree, such as
 * operators, variables, function calls, and control flow statements. Each node can be:
 * <ul>
 *   <li>Evaluated statically if constant (optimization)</li>
 *   <li>Compiled to Java bytecode for runtime execution</li>
 * </ul>
 * <p>
 * Node implementations must handle both evaluation and bytecode generation, implementing
 * the appropriate methods based on their capabilities.
 *
 * @author Buddy
 * @since 1.0.0
 */
@ApiStatus.Internal
public interface Node {

    /**
     * Returns a string representation of this node for debugging and error messages.
     *
     * @return A string describing this node
     */
    @Override
    String toString();

    /**
     * Checks if this node can be evaluated at compile-time without runtime context.
     * <p>
     * Constant nodes include literals (numbers, strings, booleans) and expressions
     * composed entirely of constants. Non-constant nodes include variable references,
     * function calls, and any operation involving runtime data.
     *
     * @return true if this node's condition is known at compile-time
     */
    boolean isConstant();

    /**
     * Checks if this node produces a condition that can be used in expressions.
     * <p>
     * Most nodes have values (literals, operations, variable access). Control flow
     * statements like {@code break} and {@code continue} do not have values.
     *
     * @return true if this node produces a condition when evaluated
     */
    boolean hasValue();

    /**
     * Evaluates this node at compile-time to produce a constant condition.
     * <p>
     * This method is only called for nodes where {@link #isConstant()} returns true.
     * It allows the compiler to optimize constant expressions by computing their values
     * during compilation instead of at runtime.
     * <p>
     * For example, the expression {@code 2 + 3} can be evaluated to {@code 5} at compile-time.
     *
     * @param environment The bytecode compilation environment
     * @return The static MolangValue result of evaluating this node
     * @throws MolangException If evaluation fails or the node cannot be statically evaluated
     * @since 3.2.0
     */
    default MolangValue evaluate(MolangBytecodeEnvironment environment) throws MolangException {
        throw new MolangException("Cannot statically evaluate " + this.getClass().getSimpleName());
    }

    /**
     * Generates Java bytecode for this node and appends it to the method.
     * <p>
     * This method is the core of the bytecode compilation process. Each node type generates
     * appropriate JVM instructions to evaluate itself at runtime. The generated bytecode should
     * leave a {@link gg.moonflower.molangcompiler.api.MolangValue} on the stack if {@link #hasValue()}
     * returns true.
     * <p>
     * For nodes within loops, the {@code breakLabel} and {@code continueLabel} parameters provide
     * jump targets for break and continue statements.
     *
     * @param method        The method node to append bytecode instructions to
     * @param environment   The bytecode compilation environment for variable allocation and tracking
     * @param breakLabel    Jump target for break statements, or null if not inside a loop
     * @param continueLabel Jump target for continue statements, or null if not inside a loop
     * @throws MolangException If bytecode generation fails due to syntax errors or unsupported operations
     */
    default void writeBytecode(MethodNode method, MolangBytecodeEnvironment environment, @Nullable Label breakLabel, @Nullable Label continueLabel) throws MolangException {
        throw new MolangException("Not implemented (" + this.getClass().getSimpleName() + " " + this + ")");
    }
}